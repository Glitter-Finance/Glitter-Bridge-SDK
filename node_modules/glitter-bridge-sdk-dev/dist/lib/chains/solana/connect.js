"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaConnect = void 0;
const web3_js_1 = require("@solana/web3.js");
const accounts_1 = require("./accounts");
const assets_1 = require("./assets");
const bridge_1 = require("./txns/bridge");
const txns_1 = require("./txns/txns");
const util = __importStar(require("util"));
const common_1 = require("../../common");
class SolanaConnect {
    constructor(config) {
        this._accounts = undefined;
        this._assets = undefined;
        this._transactions = undefined;
        this._bridgeTxnsV1 = undefined;
        this._client = new web3_js_1.Connection(config.server);
        this._accounts = new accounts_1.SolanaAccounts(this._client);
        this._assets = new assets_1.SolanaAssets(this._client);
        this._transactions = new txns_1.SolanaTxns(this._client);
        this._bridgeTxnsV1 = new bridge_1.SolanaBridgeTxnsV1(this._client, config.accounts.bridgeProgram, config.accounts);
    }
    get client() {
        return this._client;
    }
    get accounts() {
        return this._accounts;
    }
    get assets() {
        return this._assets;
    }
    createUSDCBridgeTransferInstruction(account, fromSymbol, toNetwork, toAddress, tosymbol, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._client)
                        throw new Error('Solana Client not found');
                    if (!this._bridgeTxnsV1)
                        throw new Error('Solana Bridge Transactions not found');
                    if (!this._accounts)
                        throw new Error('Solana Accounts not found');
                    if (!this._assets)
                        throw new Error('Solana Assets not found');
                    //Get Token
                    const token = common_1.BridgeTokens.get("solana", fromSymbol);
                    if (!token)
                        throw new Error("Token not found");
                    //Get routing
                    const routing = (0, common_1.RoutingDefault)();
                    routing.from.address = account.addr;
                    routing.from.token = fromSymbol;
                    routing.from.network = "solana";
                    routing.to.address = toAddress;
                    routing.to.token = tosymbol;
                    routing.to.network = toNetwork;
                    routing.amount = amount;
                    let txn = undefined;
                    if (routing.to.token.toLocaleLowerCase() === "usdc" && routing.from.token.toLocaleLowerCase() === "usdc") {
                        txn = yield this._bridgeTxnsV1.HandleUsdcSwap(account, routing);
                    }
                    resolve(txn);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    bridge(account, fromSymbol, toNetwork, toAddress, tosymbol, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._client)
                        throw new Error('Solana Client not found');
                    if (!this._bridgeTxnsV1)
                        throw new Error('Solana Bridge Transactions not found');
                    if (!this._accounts)
                        throw new Error('Solana Accounts not found');
                    if (!this._assets)
                        throw new Error('Solana Assets not found');
                    //Get Token
                    const token = common_1.BridgeTokens.get("solana", fromSymbol);
                    if (!token)
                        throw new Error("Token not found");
                    //Get routing
                    const routing = (0, common_1.RoutingDefault)();
                    routing.from.address = account.addr;
                    routing.from.token = fromSymbol;
                    routing.from.network = "solana";
                    routing.to.address = toAddress; // algo's address
                    routing.to.token = tosymbol;
                    routing.to.network = toNetwork;
                    routing.amount = amount;
                    //get token account
                    let txn = undefined;
                    if (token.symbol.toLowerCase() === "sol") {
                        txn = yield this._bridgeTxnsV1.solBridgeTransaction(account.pk, routing, token);
                    }
                    else {
                        txn = yield this._bridgeTxnsV1.tokenBridgeTransaction(account.pk, routing, token);
                    }
                    if (!txn)
                        throw new Error("Transaction not found");
                    //Send Transaction
                    const txid = yield this._client.sendTransaction(txn, [web3_js_1.Keypair.fromSecretKey(account.sk)], {
                        skipPreflight: true,
                        preflightCommitment: "processed"
                    });
                    console.log(`   âœ… - Transaction sent to network ${txid}`);
                    resolve(true);
                }
                catch (error) {
                    console.log(error);
                    reject(error);
                }
            }));
        });
    }
    //Account Actions
    fundAccount(funder, account, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail safe
                    if (!this._client)
                        throw new Error("Solana Client not defined");
                    //Get routing
                    const routing = (0, common_1.RoutingDefault)();
                    routing.from.address = funder.addr;
                    routing.from.token = "sol";
                    routing.from.network = "solana";
                    routing.to.address = account.addr;
                    routing.to.token = "sol";
                    routing.to.network = "solana";
                    routing.amount = amount;
                    let returnValue = yield this.sendSol(routing, funder);
                    resolve(returnValue);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    fundAccountTokens(funder, account, amount, symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail safe
                    if (!this._client)
                        throw new Error("Solana Client not defined");
                    //Get Token
                    const token = common_1.BridgeTokens.get("solana", symbol);
                    if (!token)
                        throw new Error("Token not found");
                    //Get routing
                    const routing = (0, common_1.RoutingDefault)();
                    routing.from.address = funder.addr;
                    routing.from.token = symbol;
                    routing.from.network = "solana";
                    routing.to.address = account.addr;
                    routing.to.token = symbol;
                    routing.to.network = "solana";
                    routing.amount = amount;
                    let returnValue = yield this.sendTokens(routing, funder, token);
                    resolve(returnValue);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    closeOutAccount(signer, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail safe
                    if (!this._client)
                        throw new Error("Solana Client not defined");
                    if (!this._transactions)
                        throw new Error("Solana Transactions not defined");
                    if (!this._accounts)
                        throw new Error("Solana Accounts not defined");
                    //Get balance
                    const balance = yield this.getBalance(signer.addr);
                    //Get routing
                    const routing = (0, common_1.RoutingDefault)();
                    routing.from.address = signer.addr;
                    routing.from.token = "sol";
                    routing.from.network = "solana";
                    routing.to.address = receiver.addr;
                    routing.to.token = "sol";
                    routing.to.network = "solana";
                    //Get sol token
                    const solToken = yield this._transactions.SolToken;
                    if (!solToken)
                        throw new Error("Sol Token not found");
                    routing.amount = common_1.ValueUnits.fromUnits(BigInt(1), solToken.decimals).value;
                    //get mock transaction
                    const mock_txn = yield this._transactions.sendSolTransaction(routing);
                    mock_txn.recentBlockhash = (yield this._client.getRecentBlockhash()).blockhash;
                    mock_txn.sign(...[accounts_1.SolanaAccounts.getSignerObject(signer)]);
                    //get fee and set amount
                    const feeUnits = yield mock_txn.getEstimatedFee(this._client);
                    const fee = common_1.ValueUnits.fromUnits(BigInt(feeUnits), solToken.decimals).value;
                    routing.amount = balance - fee;
                    const txn = yield this._transactions.sendSolTransaction(routing);
                    //Send Transactions
                    const result = yield this._client.sendTransaction(txn, [accounts_1.SolanaAccounts.getSignerObject(signer)]);
                    //console.log("Sent {0} SOL to {1} to close account", routing.amount, receiver.addr);
                    console.log(`Sent ${routing.amount} SOL to ${receiver.addr} to close account ${signer.addr}`);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    //Txn Actions
    sendSol(routing, signer) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._client)
                        throw new Error('Solana Client not found');
                    if (!this._transactions)
                        throw new Error('Solana Transactions not found');
                    if (!this._accounts)
                        throw new Error('Solana Accounts not found');
                    //Get Transactions
                    console.log(`Sending ${routing.amount} SOL from ${signer.addr} to ${routing.to.address}`);
                    const txn = yield this._transactions.sendSolTransaction(routing);
                    //Send Transactions
                    const result = yield this._client.sendTransaction(txn, [accounts_1.SolanaAccounts.getSignerObject(signer)]);
                    console.log(`SOL Sent ${result}`);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    sendTokens(routing, account, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._transactions)
                        throw new Error("Solana Transactions not defined");
                    if (!account)
                        throw new Error("Sender account is required");
                    if (!token)
                        throw new Error("Token is required");
                    if (!this._assets)
                        throw new Error("Solana Assets not defined");
                    if (!this._accounts)
                        throw new Error("Solana Accounts not defined");
                    if (!this._client)
                        throw new Error("Solana Client not defined");
                    //get token accounts
                    const senderTokenAccount = yield this._assets.getTokenAccount(account.pk, token);
                    const receiverTokenAccount = yield this._assets.getTokenAccount(new web3_js_1.PublicKey(routing.to.address), token);
                    if (!senderTokenAccount) {
                        throw new Error(`Sender Token Account not found for ${account.addr}`);
                    }
                    if (!receiverTokenAccount) {
                        throw new Error(`Receiver Token Account not found for ${routing.to.address}`);
                    }
                    //Get Txn
                    console.log(`Sending ${routing.amount} ${token.symbol} from ${routing.from.address} to ${routing.to.address}`);
                    const txn = yield this._transactions.sendTokenTransaction(routing, senderTokenAccount.address, receiverTokenAccount.address, token);
                    //Send Transactions
                    const result = yield this._client.sendTransaction(txn, [accounts_1.SolanaAccounts.getSignerObject(account)]);
                    console.log(`${token.symbol} Sent ${result}`);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    optinToken(account, symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._accounts)
                        throw new Error("Solana Accounts not defined");
                    if (!this._transactions)
                        throw new Error("Solana Transactions not defined");
                    if (!this._assets)
                        throw new Error("Solana Assets not defined");
                    //Get Token
                    const token = common_1.BridgeTokens.get("solana", symbol);
                    if (!token)
                        throw new Error("Token not found");
                    if (!token.address)
                        throw new Error("mint address is required");
                    if (typeof token.address !== "string")
                        throw new Error("token address is required in string format");
                    //Get Txn
                    console.log(`Opting in ${account.addr} to ${token.address}`);
                    //get token account
                    const tokenAccount = yield this._assets.getTokenAccount(account.pk, token);
                    if (tokenAccount) {
                        console.log(`Account ${account.addr} already opted in to ${token.address}`);
                        resolve(true);
                        return;
                    }
                    //Create new account
                    const signer = accounts_1.SolanaAccounts.getSignerObject(account);
                    const newAccount = yield this._assets.createTokenAccount(signer, account.pk, token);
                    console.log(`Account ${account.addr} opted in to ${token.address}`);
                    console.log(util.inspect(newAccount, false, 5, true));
                    // const transactions: Transaction[] = [];
                    // const txn = await this._transactions.optinTransaction(signer.addr, token.address);
                    // transactions.push(txn);
                    // //Send Txn
                    // await this.signAndSend_SingleSigner(transactions, signer);
                    console.log(`Optin Completed`);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    closeOutTokenAccount(signer, receiver, symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._transactions)
                        throw new Error("Solana Transactions not defined");
                    if (!this._assets)
                        throw new Error("Solana Assets not defined");
                    //Get balance
                    let balance = yield this.getTokenBalance(signer.addr, symbol);
                    //Get Token
                    const token = common_1.BridgeTokens.get("solana", symbol);
                    if (!token)
                        throw new Error("Token not found");
                    if (!token.address)
                        throw new Error("mint address is required");
                    if (typeof token.address !== "string")
                        throw new Error("token address is required in string format");
                    //Check if balance needs to be closed out
                    if (balance > 0) {
                        //Get routing
                        yield this.fundAccountTokens(signer, receiver, balance, symbol);
                        balance = yield this.waitForTokenBalance(signer.addr, symbol, 0);
                        console.log(`Sent ${balance} ${symbol} to ${receiver.addr}. New Balance: ${balance}`);
                    }
                    //get token account
                    const tokenAccount = yield this._assets.getTokenAccount(signer.pk, token);
                    if (!tokenAccount)
                        throw new Error("Token Account not found");
                    let txn = this._transactions.closeTokenAccountTransaction(signer.pk, tokenAccount.address);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    optinAccountExists(account, symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._assets)
                        throw new Error("Solana Assets not defined");
                    // //Get Token
                    const token = common_1.BridgeTokens.get("solana", symbol);
                    if (!token)
                        throw new Error("Token not found");
                    if (!token.address)
                        throw new Error("mint address is required");
                    if (typeof token.address !== "string")
                        throw new Error("token address is required in string format");
                    //get token account
                    const tokenAccount = yield this._assets.getTokenAccount(account.pk, token);
                    if (tokenAccount) {
                        resolve(true);
                        return;
                    }
                    else {
                        resolve(false);
                    }
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    //Account Info
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this._client)
                        throw new Error("Solana Client not defined");
                    if (!this._accounts)
                        throw new Error("Solana Accounts not defined");
                    if (!this._transactions)
                        throw new Error("Solana transactions not defined");
                    //get account
                    const account = this._accounts.getAccount(address);
                    if (!account)
                        throw new Error("Account not found");
                    //Get sol token
                    const solToken = yield this._transactions.SolToken;
                    if (!solToken)
                        throw new Error("Sol Token not found");
                    let units = yield this._client.getBalance(account.pk);
                    //Convert units to integer.  The precision round floating point errors
                    units = Number((0, common_1.Precise)(units).toString());
                    let balance = common_1.ValueUnits.fromUnits(BigInt(units), solToken.decimals).value;
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForBalance(address, expectedAmount, timeoutSeconds = 60, threshold = 0.001, anybalance = false, noBalance = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getBalance(address);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (anybalance && balance > 0) {
                            break;
                        }
                        else if (noBalance && balance == 0) {
                            break;
                        }
                        else if (Math.abs(balance - expectedAmount) < threshold) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getBalance(address);
                    }
                    //Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForMinBalance(address, minAmount, timeoutSeconds = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getBalance(address);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (balance >= minAmount) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getBalance(address);
                    }
                    //Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForBalanceChange(address, startingAmount, timeoutSeconds = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getBalance(address);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (balance != startingAmount) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getBalance(address);
                    }
                    //Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    getTokenBalance(address, symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this._client)
                        throw new Error("Solana Client not defined");
                    if (!this._accounts)
                        throw new Error("Solana Accounts not defined");
                    if (!this._transactions)
                        throw new Error("Solana transactions not defined");
                    if (!this._assets)
                        throw new Error("Solana Assets not defined");
                    //Get Token
                    const token = common_1.BridgeTokens.get("solana", symbol);
                    if (!token)
                        throw new Error("Token not found");
                    if (!token.address)
                        throw new Error("mint address is required");
                    if (typeof token.address !== "string")
                        throw new Error("token address is required in string format");
                    //get token account
                    const tokenAccount = yield this._assets.getTokenAccount(new web3_js_1.PublicKey(address), token);
                    if (!tokenAccount)
                        throw new Error("Token Account not found");
                    //Get balance (Units)
                    let unitsContext = yield this._client.getTokenAccountBalance(tokenAccount.address);
                    let unitsValue = unitsContext.value;
                    let balance = common_1.ValueUnits.fromUnits(BigInt(unitsValue.amount), unitsValue.decimals).value;
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForTokenBalance(address, symbol, expectedAmount, timeoutSeconds = 60, threshold = 0.001, anybalance = false, noBalance = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getTokenBalance(address, symbol);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (anybalance && balance > 0) {
                            break;
                        }
                        else if (noBalance && balance == 0) {
                            break;
                        }
                        else if (Math.abs(balance - expectedAmount) < threshold) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getTokenBalance(address, symbol);
                    }
                    //Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForMinTokenBalance(address, symbol, minAmount, timeoutSeconds = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getTokenBalance(address, symbol);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        if (balance >= minAmount) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getTokenBalance(address, symbol);
                    }
                    //Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForTokenBalanceChange(address, symbol, startingAmount, timeoutSeconds = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getTokenBalance(address, symbol);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        if (balance != startingAmount) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getTokenBalance(address, symbol);
                    }
                    //Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    //Helper Functions
    getTestAirDrop(signer) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this._client)
                        throw new Error('Solana Client not found');
                    const result = yield this._client.requestAirdrop(signer.pk, 1000000000);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
}
exports.SolanaConnect = SolanaConnect;
