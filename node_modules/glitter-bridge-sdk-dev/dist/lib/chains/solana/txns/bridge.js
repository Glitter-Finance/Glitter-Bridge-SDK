"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaBridgeTxnsV1 = void 0;
const borsh_1 = require("borsh");
const algosdk_1 = __importDefault(require("algosdk"));
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const common_1 = require("../../../common");
class SolanaBridgeTxnsV1 {
    //Setters
    constructor(client, bridgeProgramAddress, accounts) {
        this._bridgeProgramAddress = undefined;
        this._primarySeed = "glitter";
        this._accounts = undefined;
        this._client = client;
        this._bridgeProgramAddress = bridgeProgramAddress;
        this._accounts = accounts;
    }
    getSolEscrowAccount(account) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._bridgeProgramAddress)
                        throw new Error("Bridge Program Address is not set");
                    //Get Bridge Program PubKey
                    const bridgeProgram = new web3_js_1.PublicKey(this._bridgeProgramAddress);
                    //Get Bridge Program PubKey
                    const seeds = [
                        Buffer.from(this._primarySeed, "utf-8"),
                        account.toBuffer()
                    ];
                    const [solanaEscrowAccount] = yield web3_js_1.PublicKey.findProgramAddress(seeds, bridgeProgram);
                    console.log("solanaEscrowAccount: " + solanaEscrowAccount.toString());
                    resolve(solanaEscrowAccount);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    getTokenEscrowAccount(account) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._bridgeProgramAddress)
                        throw new Error("Bridge Program Address is not set");
                    //Get Bridge Program PubKey
                    const bridgeProgram = new web3_js_1.PublicKey(this._bridgeProgramAddress);
                    const solanaEscrowAccount = yield this.getSolEscrowAccount(account);
                    //Get Seets
                    const seeds = [
                        Buffer.from(this._primarySeed, 'utf-8'),
                        solanaEscrowAccount.toBuffer(),
                        account.toBuffer(),
                    ];
                    const [solanaEscrowTokenAccount] = yield web3_js_1.PublicKey.findProgramAddress(seeds, bridgeProgram);
                    console.log("solanaEscrowTokenAccount: " + solanaEscrowTokenAccount.toString());
                    resolve(solanaEscrowTokenAccount);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    getAssetInfoAccount(account, mintAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._bridgeProgramAddress)
                        throw new Error("Bridge Program Address is not set");
                    //Get Bridge Program PubKey
                    const bridgeProgram = new web3_js_1.PublicKey(this._bridgeProgramAddress);
                    //Get Seets
                    const seeds = [
                        Buffer.from(this._primarySeed, "utf-8"),
                        account.toBuffer(),
                        mintAccount.toBuffer(),
                    ];
                    const [assetInfoAccount] = yield web3_js_1.PublicKey.findProgramAddress(seeds, bridgeProgram);
                    console.log("assetInfoAccount: " + assetInfoAccount.toString());
                    resolve(assetInfoAccount);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    getTokenAccount(account, mintAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._bridgeProgramAddress)
                        throw new Error("Bridge Program Address is not set");
                    //Get Bridge Program PubKey
                    const bridgeProgram = new web3_js_1.PublicKey(this._bridgeProgramAddress);
                    //Get Seets
                    const seeds = [
                        account.toBuffer(),
                        spl_token_1.TOKEN_PROGRAM_ID.toBuffer(),
                        mintAccount.toBuffer(),
                    ];
                    const [solanaUserAtaAccount] = yield web3_js_1.PublicKey.findProgramAddress(seeds, spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID);
                    console.log("solanaUserAtaAccount: " + solanaUserAtaAccount.toString());
                    resolve(solanaUserAtaAccount);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    HandleUsdcSwap(account, routing) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d;
                try {
                    let transferAmount;
                    if (!routing.from.address)
                        throw new Error('Source address can not be found');
                    if (!routing.to.address)
                        throw new Error('Destination address can not be found');
                    let asset = common_1.BridgeTokens.get("solana", routing.from.token);
                    if (!asset || asset.symbol.toLocaleLowerCase() !== "usdc") {
                        throw new Error("Token Not Found");
                    }
                    if (!routing.amount) {
                        throw new Error("amount can not be null");
                    }
                    else {
                        transferAmount = routing.amount * 10 ** asset.decimals;
                    }
                    const USDCroutingData = {
                        from: {
                            token: "USDC",
                            network: routing.from.network,
                            address: routing.from.address,
                            txn_signature: "",
                        },
                        to: {
                            token: "USDC",
                            network: routing.to.network,
                            address: routing.to.address,
                            txn_signature: "",
                        },
                        amount: transferAmount / 1000000,
                        units: BigInt(transferAmount),
                    };
                    const bridgeNodeInstructionData = {
                        system: JSON.stringify({
                            from: USDCroutingData.from,
                            to: USDCroutingData.to,
                            amount: USDCroutingData.amount,
                            units: (_a = USDCroutingData.units) === null || _a === void 0 ? void 0 : _a.toString(),
                        }),
                        date: "".concat(new Date().toString()),
                    };
                    const PubKeywallet = new web3_js_1.PublicKey(USDCroutingData.from.address);
                    const usdcMint = (_b = common_1.BridgeTokens.get("solana", "usdc")) === null || _b === void 0 ? void 0 : _b.address;
                    if (!usdcMint)
                        throw new Error('USDC mint not found');
                    const destination = (_c = this._accounts) === null || _c === void 0 ? void 0 : _c.usdcDeposit;
                    if (!destination)
                        throw new Error('USDC destination not found');
                    const memoProgram = (_d = this._accounts) === null || _d === void 0 ? void 0 : _d.memoProgram;
                    if (!memoProgram)
                        throw new Error('Memo Program not found');
                    if (!this._client) {
                        throw new Error("connection not set up");
                    }
                    const usdcMint_ = yield (0, spl_token_1.getMint)(this._client, new web3_js_1.PublicKey(usdcMint));
                    const destinationPubkey = new web3_js_1.PublicKey(destination);
                    const fromTokenAccount = yield (0, spl_token_1.getOrCreateAssociatedTokenAccount)(this._client, web3_js_1.Keypair.fromSecretKey(account.sk), usdcMint_.address, PubKeywallet);
                    if (!fromTokenAccount) {
                        throw new Error("fromTokenAccount does not exist");
                    }
                    let tx = new web3_js_1.Transaction();
                    if (!(yield this._client.getAccountInfo(fromTokenAccount.address))) {
                        throw new Error('USDC not opted in, please Opt in');
                    }
                    tx.add((0, spl_token_1.createTransferInstruction)(fromTokenAccount.address, destinationPubkey, PubKeywallet, transferAmount, [], spl_token_1.TOKEN_PROGRAM_ID));
                    tx.add(new web3_js_1.TransactionInstruction({
                        keys: [
                            { pubkey: PubKeywallet, isSigner: true, isWritable: true },
                        ],
                        data: Buffer.from(JSON.stringify(bridgeNodeInstructionData), "utf-8"),
                        programId: new web3_js_1.PublicKey(memoProgram),
                    }));
                    resolve(tx);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    solBridgeTransaction(account, routing, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (token.symbol.toLowerCase() != "sol")
                        throw new Error("Token must be SOL");
                    if (!token.address)
                        throw new Error("mint address is required");
                    if (typeof token.address !== "string")
                        throw new Error("token address is required in string format");
                    if (!routing.amount)
                        throw new Error("amount is required");
                    if (!this._bridgeProgramAddress)
                        throw new Error("Bridge Program Address is not set");
                    if (!this._client)
                        throw new Error("Client is not set");
                    //Get Bridge Program PubKey
                    const bridgeProgram = new web3_js_1.PublicKey(this._bridgeProgramAddress);
                    //Get accounts
                    const solanaEscrowAccount = yield this.getSolEscrowAccount(account);
                    let toAddress = undefined;
                    if (routing.to.network == "algorand") {
                        toAddress = algosdk_1.default.decodeAddress(routing.to.address).publicKey;
                    }
                    if (!toAddress)
                        throw new Error("to address is required.  Could not deserialize address");
                    //Get Data
                    let amount = Number(common_1.ValueUnits.fromValue(routing.amount, token.decimals).units);
                    let data = (0, borsh_1.serialize)(BridgeInitSchema.init_schema, new BridgeInitSchema({
                        algo_address: toAddress,
                        amount,
                    }));
                    //Shift data
                    data = new Uint8Array([10, ...data]);
                    console.log(account.toBase58(), solanaEscrowAccount.toBase58());
                    let instructions = new web3_js_1.TransactionInstruction({
                        programId: bridgeProgram,
                        keys: [
                            { pubkey: account, isSigner: true, isWritable: true },
                            { pubkey: solanaEscrowAccount, isSigner: false, isWritable: true },
                            { pubkey: new web3_js_1.PublicKey('GdMte7MdNc3n6zFKZAmKa3TCBhPooPNJ3cBGnJc3uHnG'), isSigner: false, isWritable: false },
                            { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
                        ],
                        data: Buffer.from(data)
                    });
                    const latestBlockhash = yield this._client.getLatestBlockhash('finalized');
                    const transaction = new web3_js_1.Transaction({
                        blockhash: latestBlockhash.blockhash,
                        lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
                    });
                    transaction.add(...[instructions]);
                    resolve(transaction);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    tokenBridgeTransaction(account, routing, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (token.symbol.toLowerCase() == "sol")
                        throw new Error("Token must be SOL");
                    if (!token.address)
                        throw new Error("mint address is required");
                    if (typeof token.address !== "string")
                        throw new Error("token address is required in string format");
                    if (!routing.amount)
                        throw new Error("amount is required");
                    // if (!this._bridgeProgramAddress) throw new Error("Bridge Program Address is not set");
                    if (!this._client)
                        throw new Error("Client is not set");
                    //Get Bridge Program PubKey
                    const bridgeProgram = new web3_js_1.PublicKey(this._bridgeProgramAddress);
                    //Get accounts
                    const solEscrowAccount = yield this.getSolEscrowAccount(account);
                    const tokenEscrowAccount = yield this.getTokenEscrowAccount(account);
                    const userTokenAccount = yield this.getTokenAccount(account, new web3_js_1.PublicKey(token.address));
                    const mintToken = new web3_js_1.PublicKey(token.address);
                    //const solanaEscrowA = await this._client.getAccountInfo(solanaEscrowAccount  )
                    //console.log(util.inspect(solanaEscrowA, false, 5, true /* enable colors */))
                    let toAddress = undefined;
                    if (routing.to.network == "algorand") {
                        toAddress = algosdk_1.default.decodeAddress(routing.to.address).publicKey;
                    }
                    if (!toAddress)
                        throw new Error("to address is required.  Could not deserialize address");
                    //Get Data
                    let amount = Number(common_1.ValueUnits.fromValue(routing.amount, token.decimals).units);
                    let data = (0, borsh_1.serialize)(BridgeInitSchema.init_schema, new BridgeInitSchema({
                        algo_address: toAddress,
                        amount,
                    }));
                    //Shift data
                    data = new Uint8Array([20, ...data]);
                    console.log(account.toBase58(), solEscrowAccount.toBase58());
                    let instructions = new web3_js_1.TransactionInstruction({
                        programId: bridgeProgram,
                        keys: [
                            { pubkey: account, isSigner: true, isWritable: false },
                            { pubkey: userTokenAccount, isSigner: false, isWritable: true },
                            { pubkey: solEscrowAccount, isSigner: false, isWritable: true },
                            { pubkey: tokenEscrowAccount, isSigner: false, isWritable: true },
                            { pubkey: new web3_js_1.PublicKey('2g1SsjER76eKTLsSCdpDyB726ba8SwvN23YMoknTHvmX'), isSigner: false, isWritable: false },
                            { pubkey: mintToken, isSigner: false, isWritable: false },
                            { pubkey: spl_token_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                            { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
                        ],
                        data: Buffer.from(data)
                    });
                    const latestBlockhash = yield this._client.getLatestBlockhash('finalized');
                    const transaction = new web3_js_1.Transaction({
                        blockhash: latestBlockhash.blockhash,
                        lastValidBlockHeight: latestBlockhash.lastValidBlockHeight
                    });
                    transaction.add(...[instructions]);
                    resolve(transaction);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
}
exports.SolanaBridgeTxnsV1 = SolanaBridgeTxnsV1;
class BridgeInitSchema {
    constructor(properties) {
        this.algo_address = properties.algo_address;
        this.amount = properties.amount;
    }
}
BridgeInitSchema.init_schema = new Map([
    [
        BridgeInitSchema,
        {
            kind: "struct",
            fields: [
                ["algo_address", [32]],
                ["amount", "u64"],
            ],
        },
    ],
]);
class BridgeSetSchema {
    constructor(properties) {
        this.validator_address = properties.validator_address;
    }
}
BridgeSetSchema.set_schema = new Map([
    [
        BridgeSetSchema,
        {
            kind: "struct",
            fields: [
                ["validator_address", [32]],
            ],
        },
    ],
]);
