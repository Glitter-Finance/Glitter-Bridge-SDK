"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolanaTxns = void 0;
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const common_1 = require("../../../common");
class SolanaTxns {
    //Setters
    constructor(client) {
        this._client = client;
    }
    get SolToken() {
        if (!this._solToken) {
            this._solToken = common_1.BridgeTokens.get("solana", "sol");
        }
        return this._solToken;
    }
    sendSolTransaction(routing) {
        if (!this._client)
            throw new Error('Solana Client not found');
        if (!routing)
            throw new Error('Routing not found');
        if (!routing.amount)
            throw new Error('Amount not found');
        //Get Sol Token
        const solToken = this.SolToken;
        if (!solToken)
            throw new Error('Sol Token not found');
        const txn = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.transfer({
            fromPubkey: new web3_js_1.PublicKey(routing.from.address),
            toPubkey: new web3_js_1.PublicKey(routing.to.address),
            lamports: common_1.ValueUnits.fromValue(routing.amount, solToken.decimals).units, // 1 SOL = 1,000,000,000 lamports
        }));
        return (txn);
    }
    sendTokenTransaction(routing, senderTokenAccount, recipientTokenAccount, token) {
        if (!this._client)
            throw new Error('Solana Client not found');
        if (!routing)
            throw new Error('Routing not found');
        if (!routing.amount)
            throw new Error('Amount not found');
        if (!token)
            throw new Error('Token not found');
        if (!token.address)
            throw new Error('Token address not found');
        if (typeof token.address !== "string")
            throw new Error('Token address not found in string format');
        const txn = new web3_js_1.Transaction().add((0, spl_token_1.createTransferCheckedInstruction)(senderTokenAccount, new web3_js_1.PublicKey(token.address), recipientTokenAccount, new web3_js_1.PublicKey(routing.from.address), common_1.ValueUnits.fromValue(routing.amount, token.decimals).units, token.decimals));
        return txn;
    }
    ;
    closeTokenAccountTransaction(senderAccount, senderTokenAccount) {
        let tx = new web3_js_1.Transaction();
        tx.add((0, spl_token_1.createCloseAccountInstruction)(senderTokenAccount, // to be closed token account
        senderAccount, // rent's destination
        senderAccount, // token account authority
        [] // multisig
        ));
        tx.feePayer = senderAccount;
    }
}
exports.SolanaTxns = SolanaTxns;
