"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmConnect = void 0;
const ethers_1 = require("ethers");
const glitter_evm_contracts_1 = require("glitter-evm-contracts");
const events_1 = require("./events");
const serde_1 = require("./serde");
class EvmConnect {
    createConnections(rpcUrl, config) {
        const bridgeAddress = config.bridge;
        const rpcProvider = new ethers_1.ethers.providers.JsonRpcProvider(rpcUrl);
        const bridge = glitter_evm_contracts_1.TokenBridge__factory.connect(bridgeAddress, rpcProvider);
        const tokens = config.tokens.reduce((_tokens, curr) => {
            const symbol = curr.symbol.toLowerCase();
            _tokens[symbol] = glitter_evm_contracts_1.ERC20__factory.connect(curr.address, rpcProvider);
            return _tokens;
        }, {});
        return {
            rpcProvider,
            bridge,
            tokens,
        };
    }
    constructor(network, config) {
        this.__config = config;
        this.__network = network;
        this.__providers = this.createConnections(config.rpcUrl, config);
    }
    getAddress(entity, tokenSymbol) {
        if (entity === "tokens") {
            if (!tokenSymbol)
                throw new Error("[EvmConnect] Please provide token symbol.");
            const token = this.__config.tokens.find((token) => token.symbol.toLowerCase() === tokenSymbol.toLowerCase());
            if (!token) {
                throw new Error("[EvmConnect] Can not provide address of undefined token.");
            }
            return token.address.toLowerCase();
        }
        return this.__config[entity].toLowerCase();
    }
    isValidToken(tokenSymbol) {
        return !!this.__providers.tokens[tokenSymbol.toLowerCase()];
    }
    getTokenBalanceOnNetwork(tokenSymbol, address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isValidToken(tokenSymbol))
                return Promise.reject("[EvmConnect] Unsupported token symbol.");
            const erc20 = this.__providers.tokens[tokenSymbol];
            const balance = yield erc20.balanceOf(address);
            return balance;
        });
    }
    approveTokensForBridge(tokenSymbol, amount, signer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isValidToken(tokenSymbol))
                return Promise.reject("[EvmConnect] Unsupported token symbol.");
            const bridgeAddress = this.getAddress("bridge");
            const tokenAddress = this.getAddress("tokens", tokenSymbol);
            const token = glitter_evm_contracts_1.ERC20__factory.connect(tokenAddress, signer);
            return yield token.increaseAllowance(bridgeAddress, amount);
        });
    }
    bridgeAllowance(tokenSymbol, signer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isValidToken(tokenSymbol))
                return Promise.reject("Unsupported token symbol.");
            const tokenAddress = this.getAddress("tokens", tokenSymbol);
            const usdc = glitter_evm_contracts_1.ERC20__factory.connect(tokenAddress, signer);
            const allowance = yield usdc.allowance(signer.getAddress(), this.getAddress("bridge", tokenSymbol));
            return allowance;
        });
    }
    parseLogs(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let events = [];
                const parser = new events_1.EvmBridgeEventsParser();
                const transactionReceipt = yield this.__providers.rpcProvider.getTransactionReceipt(txHash);
                for (const log of transactionReceipt.logs) {
                    const deposit = parser.parseDeposit([log]);
                    const release = parser.parseRelease([log]);
                    const transfer = parser.parseTransfer([log]);
                    if (deposit)
                        events.push(deposit);
                    if (release)
                        events.push(release);
                    if (transfer)
                        events.push(transfer);
                }
                return events;
            }
            catch (error) {
                return Promise.reject(error.message);
            }
        });
    }
    isCorrectChain(wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainId = yield wallet.getChainId();
            return this.__config.chainId === chainId;
        });
    }
    bridge(destination, tokenSymbol, amount, destinationWallet, wallet) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const isCorrectChain = yield this.isCorrectChain(wallet);
                if (!isCorrectChain)
                    throw new Error(`[EvmConnect] Signer should be connected to network ${this.__network}`);
                if (!this.isValidToken(tokenSymbol)) {
                    throw new Error(`[EvmConnect] Unsupported token symbol.`);
                }
                const bridge = glitter_evm_contracts_1.TokenBridge__factory.connect(this.getAddress("bridge"), wallet);
                const tokenAddress = this.getAddress("tokens", tokenSymbol);
                const depositAddress = this.getAddress("depositWallet");
                const _amount = typeof amount === "string" ? ethers_1.ethers.BigNumber.from(amount) : amount;
                const serlized = serde_1.SerializeEvmBridgeTransfer.serialize(this.__network, destination, wallet.address, destinationWallet, _amount);
                return yield bridge.deposit(serlized.destinationChain, serlized.amount, depositAddress, tokenAddress, serlized.destinationWallet);
            }
            catch (error) {
                return Promise.reject(error);
            }
        });
    }
}
exports.EvmConnect = EvmConnect;
