"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeserializeEvmBridgeTransfer = exports.SerializeEvmBridgeTransfer = void 0;
const web3_js_1 = require("@solana/web3.js");
const ethers_1 = require("ethers");
const bytes_1 = require("../../common/utils/bytes");
const algosdk_1 = __importDefault(require("algosdk"));
const networks_1 = require("../../common/networks/networks");
class SerializeEvmBridgeTransfer {
    /**
     * Convert encoded addresses to bytes
     * @param {Network} sourceChain
     * @param {string | algoSdk.Account | PublicKey} address
     * @returns hex string
     */
    static serializeAddress(sourceChain, account) {
        switch (sourceChain) {
            case networks_1.BridgeNetworks.solana:
                return ethers_1.ethers.utils
                    .hexZeroPad(account.toBytes(), 32)
                    .toString();
            case networks_1.BridgeNetworks.Polygon:
            case networks_1.BridgeNetworks.Avalanche:
            case networks_1.BridgeNetworks.Ethereum:
                return account;
            case networks_1.BridgeNetworks.algorand:
                return ethers_1.ethers.utils
                    .hexZeroPad(algosdk_1.default.decodeAddress(account.addr).publicKey, 32)
                    .toString();
        }
    }
    /**
     * Serialize bridge transfer parameters
     * @param {BridgeEvmNetworks} sourceChain
     * @param {BridgeEvmNetworks | BridgeNetworks} destinationChain
     * @param {string} sourceWallet
     * @param {PublicKey | algoSdk.Account | string} destinationWallet
     * @param {ethers.BigNumber} amount
     * @returns Serialized transfer
     */
    static serialize(sourceChain, destinationChain, sourceWallet, destinationWallet, amount) {
        const _sourceChain = Object.entries(networks_1.NetworkIdentifiers).find(([_id, network]) => {
            return network === sourceChain;
        });
        const _destinationChain = Object.entries(networks_1.NetworkIdentifiers).find(([_id, network]) => {
            return network === destinationChain;
        });
        if (!_sourceChain || !_destinationChain)
            throw new Error("[SerializeEvmBridgeTransfer] Unable to serialize bridge transfer networks");
        return {
            sourceChain: Number(_sourceChain[0]),
            destinationChain: Number(_destinationChain[0]),
            destinationWallet: SerializeEvmBridgeTransfer.serializeAddress(_destinationChain[1], destinationWallet),
            sourceWallet,
            amount: amount.toString(),
        };
    }
}
exports.SerializeEvmBridgeTransfer = SerializeEvmBridgeTransfer;
class DeserializeEvmBridgeTransfer {
    /**
     * Deserialize address from bytes
     * @param {Network} sourceChain
     * @param {string} address
     * @returns {string} formatted address
     */
    static deserializeAddress(chain, data) {
        switch (chain) {
            case networks_1.BridgeNetworks.algorand:
                return algosdk_1.default.encodeAddress((0, bytes_1.fromHexString)(data));
            case networks_1.BridgeNetworks.Polygon:
            case networks_1.BridgeNetworks.Avalanche:
            case networks_1.BridgeNetworks.Ethereum:
                return `0x${data.toLowerCase()}`;
            case networks_1.BridgeNetworks.solana:
                return new web3_js_1.PublicKey((0, bytes_1.fromHexString)(data)).toString();
        }
    }
    static deserialize(sourceChainId, destinationChainId, sourceWallet, destinationIdBytes, amount) {
        const sourceChain = Object.entries(networks_1.NetworkIdentifiers).find(([_id, _network]) => {
            return Number(_id) === sourceChainId;
        });
        const destinationChain = Object.entries(networks_1.NetworkIdentifiers).find(([_id, _network]) => {
            return Number(_id) === destinationChainId;
        });
        if (!sourceChain || !destinationChain)
            throw new Error("[DeserializeEvmBridgeTransfer] Unable to deserialize bridge transfer networks");
        return {
            sourceNetwork: sourceChain[1],
            destinationNetwork: destinationChain[1],
            amount,
            sourceWallet,
            destinationWallet: DeserializeEvmBridgeTransfer.deserializeAddress(destinationChain[1], 
            // omit '0x'
            destinationIdBytes.slice(2)),
        };
    }
}
exports.DeserializeEvmBridgeTransfer = DeserializeEvmBridgeTransfer;
