"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgorandAssets = void 0;
const common_1 = require("../../common");
class AlgorandAssets {
    //constructor
    constructor(algoClient) {
        this._assets = {};
        this._client = undefined;
        this._client = algoClient;
    }
    add(asset_id) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!asset_id)
                        throw new Error("asset_id not defined");
                    if (!this._client)
                        throw new Error("Algorand Client not defined");
                    //Check if already exists
                    if (this._assets[asset_id.toString()]) {
                        resolve(this._assets[asset_id.toString()]);
                        return;
                    }
                    //Get Asset Info
                    let asset = undefined;
                    //Get Balance
                    const assetInfo = yield this._client.getAssetByID(asset_id).do();
                    asset = this.updateInfo(asset, assetInfo);
                    //console.log(util.inspect(assetInfo, false, 5, true /* enable colors */));
                    resolve(asset);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    updateInfo(asset, assetInfo) {
        if (!asset)
            asset = {};
        asset.index = assetInfo.index;
        asset.created_round = assetInfo.created_round;
        asset.deleted = assetInfo.deleted;
        asset.clawback = assetInfo.params.clawback;
        asset.creator = assetInfo.params.creator;
        asset.decimals = assetInfo.params.decimals;
        asset.default_frozen = assetInfo.params.default_frozen;
        asset.freeze = assetInfo.params.freeze;
        asset.manager = assetInfo.params.manager;
        asset.metadata_hash = assetInfo.params.metadata_hash;
        asset.name = assetInfo.params.name;
        asset.reserve = assetInfo.params.reserve;
        asset.total = assetInfo.params.total;
        asset.total_in_decimal = common_1.ValueUnits.fromUnits(assetInfo.params.total, assetInfo.params.decimals).value;
        asset.unit_name = assetInfo.params.unit_name;
        asset.url = assetInfo.params.url;
        return asset;
    }
}
exports.AlgorandAssets = AlgorandAssets;
