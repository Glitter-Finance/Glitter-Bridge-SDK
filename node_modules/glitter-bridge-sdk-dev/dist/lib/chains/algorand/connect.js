"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetAlgodClient = exports.GetAlgodIndexer = exports.AlgorandConnect = void 0;
const algosdk = __importStar(require("algosdk"));
const accounts_1 = require("./accounts");
const txns_1 = require("./txns/txns");
const assets_1 = require("./assets");
const bridge_1 = require("./txns/bridge");
const fs = __importStar(require("fs"));
const common_1 = require("../../common");
/**
 * Connection to the Algorand network
 *
 */
class AlgorandConnect {
    constructor(config) {
        this._clientIndexer = undefined;
        this._client = undefined;
        this._accounts = undefined;
        this._assets = undefined;
        this._transactions = undefined;
        this._bridgeTxnsV1 = undefined;
        this._client = (0, exports.GetAlgodClient)(config.serverUrl, config.serverPort, config.nativeToken);
        this._clientIndexer = (0, exports.GetAlgodIndexer)(config.indexerUrl, config.indexerUrl, config.nativeToken);
        this._accounts = new accounts_1.AlgorandAccounts(this._client);
        this._assets = new assets_1.AlgorandAssets(this._client);
        this._transactions = new txns_1.AlgorandTxns(this._client, config.accounts);
        this._bridgeTxnsV1 = new bridge_1.AlgorandBridgeTxnsV1(this._client, config.appProgramId, this._transactions, config.accounts);
    }
    //Getters
    get client() {
        return this._client;
    }
    get clientIndexer() {
        return this._clientIndexer;
    }
    get accounts() {
        return this._accounts;
    }
    get assets() {
        return this._assets;
    }
    //Check
    checkHealth() {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this._client)
                    throw new Error("Algorand Client not defined");
                let returnValue = yield this._client.healthCheck().do();
                resolve(returnValue);
            }
            catch (error) {
                reject(error);
            }
        }));
    }
    checkVersion() {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this._client)
                    throw new Error("Algorand Client not defined");
                let returnValue = yield this._client.versionsCheck().do();
                resolve(returnValue);
            }
            catch (error) {
                reject(error);
            }
        }));
    }
    createUSDCBridgeTransfer(account, fromSymbol, toNetwork, toAddress, tosymbol, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this._client)
                        throw new Error("Algorand Client not defined");
                    if (!this._bridgeTxnsV1)
                        throw new Error("Algorand Bridge Txns not defined");
                    // Routing 
                    const routing = (0, common_1.RoutingDefault)();
                    routing.from.address = account.addr;
                    routing.from.token = fromSymbol;
                    routing.from.network = "algorand";
                    routing.to.address = toAddress;
                    routing.to.token = tosymbol;
                    routing.to.network = toNetwork;
                    routing.amount = amount;
                    //Get Token
                    const asset = common_1.BridgeTokens.get("algorand", fromSymbol);
                    if (!asset)
                        throw new Error("Asset not found");
                    let txn = undefined;
                    if (routing.from.token == "USDC" && routing.to.token == "USDC") {
                        txn = yield this._bridgeTxnsV1.HandleUsdcSwap(routing);
                        console.log(`Algorand USDC Transaction Complete`);
                        resolve(txn);
                    }
                    resolve(txn);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    //Bridge Actions
    bridge(account, fromSymbol, toNetwork, toAddress, tosymbol, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this._client)
                        throw new Error("Algorand Client not defined");
                    if (!this._bridgeTxnsV1)
                        throw new Error("Algorand Bridge Txns not defined");
                    //Get Token
                    const asset = common_1.BridgeTokens.get("algorand", fromSymbol);
                    // ?? asset should be xsol 
                    if (!asset)
                        throw new Error("Asset not found");
                    //Get routing
                    const routing = (0, common_1.RoutingDefault)();
                    routing.from.address = account.addr;
                    routing.from.token = fromSymbol;
                    routing.from.network = "algorand";
                    routing.to.address = toAddress;
                    routing.to.token = tosymbol;
                    routing.to.network = toNetwork;
                    routing.amount = amount;
                    //Run Transaction
                    let transactions = yield this._bridgeTxnsV1.bridgeTransactions(routing, asset);
                    let result = yield this.signAndSend_SingleSigner(transactions, account);
                    console.log(`Algorand Bridge Transaction Complete`);
                    resolve(true);
                    resolve(false);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    //Account Actions
    fundAccount(funder, account, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this._client)
                        throw new Error("Algorand Client not defined");
                    //Get routing
                    const routing = (0, common_1.RoutingDefault)();
                    routing.from.address = funder.addr;
                    routing.from.token = "algo";
                    routing.from.network = "algorand";
                    routing.to.address = account.addr;
                    routing.to.token = "algo";
                    routing.to.network = "algorand";
                    routing.amount = amount;
                    let returnValue = yield this.sendAlgo(routing, funder);
                    resolve(returnValue);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    fundAccountToken(funder, account, amount, symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this._client)
                        throw new Error("Algorand Client not defined");
                    //Get Token
                    const asset = common_1.BridgeTokens.get("algorand", symbol);
                    if (!asset)
                        throw new Error("Asset not found");
                    //Get routing
                    const routing = (0, common_1.RoutingDefault)();
                    routing.from.address = funder.addr;
                    routing.from.token = symbol;
                    routing.from.network = "algorand";
                    routing.to.address = account.addr;
                    routing.to.token = symbol;
                    routing.to.network = "algorand";
                    routing.amount = amount;
                    let returnValue = yield this.sendTokens(routing, funder, asset);
                    resolve(returnValue);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    //Txn Actions
    sendAlgo(routing, signer, debug_rootPath) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._transactions)
                        throw new Error("Algorand Transactions not defined");
                    if (!signer)
                        throw new Error("Signer is required");
                    //Get Txns
                    const transactions = [];
                    transactions.push(yield this._transactions.sendAlgoTransaction(routing));
                    //Send
                    yield this.signAndSend_SingleSigner(transactions, signer, debug_rootPath);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    sendTokens(routing, signer, token, debug_rootPath) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._transactions)
                        throw new Error("Algorand Transactions not defined");
                    if (!signer)
                        throw new Error("Signer is required");
                    //Get Txn
                    console.log(`Sending ${routing.amount} ${token.symbol} from ${routing.from.address} to ${routing.to.address}`);
                    const transactions = [];
                    transactions.push(yield this._transactions.sendTokensTransaction(routing, token));
                    //Send
                    yield this.signAndSend_SingleSigner(transactions, signer, debug_rootPath);
                    console.log(`Txn Completed`);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    mintTokens(signers, msigParams, routing, token, debug_rootPath) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._transactions)
                        throw new Error("Algorand Transactions not defined");
                    //Get Txn
                    console.log(`Minting ${routing.amount} ${token.symbol} to ${routing.to.address}`);
                    const transactions = [];
                    transactions.push(yield this._transactions.sendTokensTransaction(routing, token));
                    //Send
                    yield this.signAndSend_MultiSig(transactions, signers, msigParams, debug_rootPath);
                    console.log("Minting Completed");
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    optinToken(signer, symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get Token
                    const token = common_1.BridgeTokens.get("algorand", symbol);
                    if (!token)
                        throw new Error("Token not found");
                    //Fail Safe
                    if (!this._transactions)
                        throw new Error("Algorand Transactions not defined");
                    if (!token.address)
                        throw new Error("asset_id is required");
                    if (typeof token.address !== "number")
                        throw new Error("token address is required in number format");
                    //Get Txn
                    console.log(`Opting in ${signer.addr} to ${token.address}`);
                    const transactions = [];
                    const txn = yield this._transactions.optinTransaction(signer.addr, token.address);
                    transactions.push(txn);
                    //Send Txn
                    yield this.signAndSend_SingleSigner(transactions, signer);
                    console.log(`Optin Completed`);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    closeOutTokenAccount(signer, receiver, symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get Token
                    const token = common_1.BridgeTokens.get("algorand", symbol);
                    if (!token)
                        throw new Error("Token not found");
                    //Fail Safe
                    if (!this._transactions)
                        throw new Error("Algorand Transactions not defined");
                    if (!token.address)
                        throw new Error("asset_id is required");
                    if (typeof token.address !== "number")
                        throw new Error("address is required in number format");
                    //Get Txns                
                    console.log(`Closing out token account for ${signer.addr} to ${receiver}`);
                    const transactions = [];
                    const txn = yield this._transactions.closeOutTokenTransaction(signer.addr, receiver, token.address);
                    transactions.push(txn);
                    //Send Txn
                    yield this.signAndSend_SingleSigner(transactions, signer);
                    console.log(`Token Closeout Completed`);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    closeOutAccount(signer, receiver) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._transactions)
                        throw new Error("Algorand Transactions not defined");
                    //Get txns
                    console.log(`Closing out token account for ${signer.addr} to ${receiver}`);
                    const transactions = [];
                    const txn = yield this._transactions.closeOutAccountTransaction(signer.addr, receiver);
                    transactions.push(txn);
                    //Send Txn
                    yield this.signAndSend_SingleSigner(transactions, signer);
                    console.log(`Closeout Completed`);
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    //Txn Helpers
    signAndSend_SingleSigner(groupedTxns, signer, debug_rootPath) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._transactions)
                        throw new Error("Algorand Transactions not defined");
                    if (!this._client)
                        throw new Error("Algorand Client not defined");
                    if (!signer)
                        throw new Error("Signer not defined");
                    if (!signer.sk)
                        throw new Error("Signer Secret Key is required");
                    //Check Txns
                    if (groupedTxns.length == 0)
                        throw new Error("No Transactions to sign");
                    if (groupedTxns.length > 4)
                        throw new Error("Maximum 4 Transactions in a group");
                    const signedTxns = [];
                    const groupID = algosdk.computeGroupID(groupedTxns);
                    for (let i = 0; i < groupedTxns.length; i++) {
                        groupedTxns[i].group = groupID;
                        const signedTxn = groupedTxns[i].signTxn(signer.sk);
                        signedTxns.push(signedTxn);
                    }
                    if (debug_rootPath) {
                        yield this.createDryrun(signedTxns, debug_rootPath);
                    }
                    //Prep and Send Transactions
                    console.log('------------------------------');
                    const txnResult = yield this._client.sendRawTransaction(signedTxns).do();
                    yield algosdk.waitForConfirmation(this._client, groupedTxns[0].txID().toString(), 4);
                    console.log('------------------------------');
                    console.log('Group Transaction ID: ' + txnResult.txId);
                    for (let i = 0; i < groupedTxns.length; i++) {
                        const txnID = groupedTxns[i].txID().toString();
                        console.log('Transaction ' + i + ': ' + txnID);
                    }
                    console.log('------------------------------');
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    signAndSend_MultiSig(groupedTxns, signers, mParams, debug_rootPath) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._client)
                        throw new Error("Algorand Client not defined");
                    //Check signers
                    if (signers.length == 0)
                        throw new Error("No Signers");
                    signers.forEach((signer) => {
                        if (!signer)
                            throw new Error("Signer not defined");
                        if (!signer.sk)
                            throw new Error("Signer Secret Key is required");
                    });
                    //Check Txns
                    if (groupedTxns.length == 0)
                        throw new Error("No Transactions to sign");
                    if (groupedTxns.length > 4)
                        throw new Error("Maximum 4 Transactions in a group");
                    const signedTxns = [];
                    const groupID = algosdk.computeGroupID(groupedTxns);
                    for (let i = 0; i < groupedTxns.length; i++) {
                        groupedTxns[i].group = groupID;
                        let signedTxn = algosdk.signMultisigTransaction(groupedTxns[i], mParams, signers[0].sk).blob;
                        for (let j = 1; j < signers.length; j++) {
                            signedTxn = algosdk.appendSignMultisigTransaction(signedTxn, mParams, signers[j].sk).blob;
                        }
                        signedTxns.push(signedTxn);
                    }
                    if (debug_rootPath) {
                        console.log(`Creating Dryrun at ${debug_rootPath}`);
                        yield this.createDryrun(signedTxns, debug_rootPath);
                    }
                    //Prep and Send Transactions
                    console.log('------------------------------');
                    const txnResult = yield this._client.sendRawTransaction(signedTxns).do();
                    yield algosdk.waitForConfirmation(this._client, groupedTxns[0].txID().toString(), 4);
                    console.log('------------------------------');
                    console.log('Group Transaction ID: ' + txnResult.txId);
                    for (let i = 0; i < groupedTxns.length; i++) {
                        const txnID = groupedTxns[i].txID().toString();
                        console.log('Transaction ' + i + ': ' + txnID);
                    }
                    console.log('------------------------------');
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    createDryrun(rawSignedTxnBuff, rootPath) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!this._client)
                        throw new Error("Algorand Client not defined");
                    //Make sure root path is defined
                    if (!rootPath)
                        resolve(false);
                    let dryRun = null;
                    const txnsDecoded = rawSignedTxnBuff.map((txn) => {
                        return algosdk.decodeSignedTransaction(txn);
                    });
                    dryRun = yield algosdk.createDryrun({
                        client: this._client,
                        txns: txnsDecoded,
                    });
                    console.log(rootPath + '/tests/debug/algodebug.msgp');
                    yield fs.writeFile(rootPath + '/tests/debug/algodebug.msgp', algosdk.encodeObj(dryRun.get_obj_for_encoding(true)), (error) => {
                        if (error)
                            throw error;
                    });
                    resolve(true);
                }
                catch (error) {
                    console.log(error);
                    resolve(false);
                }
            }));
        });
    }
    //Account Info
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this._accounts)
                        throw new Error("Algorand Accounts not defined");
                    const balance = yield this._accounts.getBalance(address);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForBalance(address, expectedAmount, timeoutSeconds = 60, threshold = 0.001, anybalance = false, noBalance = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getBalance(address);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (anybalance && balance > 0) {
                            break;
                        }
                        else if (noBalance && balance == 0) {
                            break;
                        }
                        else if (Math.abs(balance - expectedAmount) < threshold) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getBalance(address);
                    }
                    //Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForMinBalance(address, minAmount, timeoutSeconds = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getBalance(address);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (balance >= minAmount) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getBalance(address);
                    }
                    //Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForBalanceChange(address, startingAmount, timeoutSeconds = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getBalance(address);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (balance != startingAmount) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getBalance(address);
                    }
                    //Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`$bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    getTokenBalance(address, symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!this._accounts)
                        throw new Error("Algorand Accounts not defined");
                    //Get Token
                    const token = common_1.BridgeTokens.get("algorand", symbol);
                    if (!token)
                        throw new Error("Token not found");
                    if (!token.address)
                        throw new Error("mint address is required");
                    if (typeof token.address !== "number")
                        throw new Error("token address is required in number format");
                    //Get Token Balance
                    const balance = yield this._accounts.getTokensHeld(address, token);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForTokenBalance(address, symbol, expectedAmount, timeoutSeconds = 60, threshold = 0.001, anybalance = false, noBalance = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getTokenBalance(address, symbol);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (anybalance && balance > 0) {
                            break;
                        }
                        else if (noBalance && balance == 0) {
                            break;
                        }
                        else if (Math.abs(balance - expectedAmount) < threshold) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getTokenBalance(address, symbol);
                    }
                    //Final Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForMinTokenBalance(address, symbol, minAmount, timeoutSeconds = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getTokenBalance(address, symbol);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (balance >= minAmount) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getTokenBalance(address, symbol);
                    }
                    //Final Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    waitForTokenBalanceChange(address, symbol, startingAmount, timeoutSeconds = 60) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Get start time & balance
                    const start = Date.now();
                    let balance = yield this.getTokenBalance(address, symbol);
                    //Loop until balance (or timeout) is reached
                    while (true) {
                        //Check break conditions
                        if (balance != startingAmount) {
                            break;
                        }
                        //Log
                        let timeInSeconds = (Date.now() - start) / 1000;
                        (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                        //Check timeout
                        if (Date.now() - start > timeoutSeconds * 1000) {
                            reject(new Error("Timeout waiting for balance"));
                        }
                        //Wait and Check balance
                        yield (0, common_1.Sleep)(1000);
                        balance = yield this.getTokenBalance(address, symbol);
                    }
                    //Final Log
                    let timeInSeconds = (Date.now() - start) / 1000;
                    (0, common_1.LogProgress)(`${symbol} bal. (${balance}), Timeout in ${Math.round((timeoutSeconds - timeInSeconds) * 10) / 10}s`);
                    resolve(balance);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
}
exports.AlgorandConnect = AlgorandConnect;
const GetAlgodIndexer = (url, port, token = '') => {
    // const server = config.algo_client;
    // const port   = config.algo_port;
    console.log(`Connecting to Algorand Indexer at ${url}:${port}`);
    const indexer = new algosdk.Indexer(token, url, port);
    indexer.setIntEncoding(algosdk.IntDecoding.MIXED);
    return indexer;
};
exports.GetAlgodIndexer = GetAlgodIndexer;
const GetAlgodClient = (url, port, token) => {
    console.log(`Connecting to Algorand Client at ${url}:${port}`);
    const client = new algosdk.Algodv2(token, url, port);
    client.setIntEncoding(algosdk.IntDecoding.MIXED);
    return client;
};
exports.GetAlgodClient = GetAlgodClient;
