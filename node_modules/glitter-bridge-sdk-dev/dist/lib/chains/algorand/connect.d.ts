import * as algosdk from 'algosdk';
import { Account, Transaction } from "algosdk";
import { AlgorandAccount, AlgorandAccounts } from "./accounts";
import { AlgorandConfig } from "./config";
import { AlgorandAssets } from "./assets";
import { BridgeToken, Routing } from '../../common';
/**
 * Connection to the Algorand network
 *
 */
export declare class AlgorandConnect {
    private _clientIndexer;
    private _client;
    private _accounts;
    private _assets;
    private _transactions;
    private _bridgeTxnsV1;
    constructor(config: AlgorandConfig);
    get client(): algosdk.Algodv2 | undefined;
    get clientIndexer(): algosdk.Indexer | undefined;
    get accounts(): AlgorandAccounts | undefined;
    get assets(): AlgorandAssets | undefined;
    checkHealth(): Promise<{}>;
    checkVersion(): Promise<{}>;
    createUSDCBridgeTransfer(account: AlgorandAccount, fromSymbol: string, toNetwork: string, toAddress: string, tosymbol: string, amount: number): Promise<Transaction[] | undefined>;
    bridge(account: AlgorandAccount, fromSymbol: string, toNetwork: string, toAddress: string, tosymbol: string, amount: number): Promise<boolean>;
    fundAccount(funder: AlgorandAccount, account: AlgorandAccount, amount: number): Promise<boolean>;
    fundAccountToken(funder: AlgorandAccount, account: AlgorandAccount, amount: number, symbol: string): Promise<boolean>;
    sendAlgo(routing: Routing, signer: Account, debug_rootPath?: string): Promise<boolean>;
    sendTokens(routing: Routing, signer: Account, token: BridgeToken, debug_rootPath?: string): Promise<boolean>;
    mintTokens(signers: Account[], msigParams: algosdk.MultisigMetadata, routing: Routing, token: BridgeToken, debug_rootPath?: string): Promise<boolean>;
    optinToken(signer: Account, symbol: string): Promise<boolean>;
    closeOutTokenAccount(signer: Account, receiver: string, symbol: string): Promise<boolean>;
    closeOutAccount(signer: AlgorandAccount, receiver: string): Promise<boolean>;
    signAndSend_SingleSigner(groupedTxns: Transaction[], signer: Account, debug_rootPath?: string): Promise<boolean>;
    signAndSend_MultiSig(groupedTxns: Transaction[], signers: Account[], mParams: algosdk.MultisigMetadata, debug_rootPath?: string): Promise<boolean>;
    createDryrun(rawSignedTxnBuff: Uint8Array[], rootPath?: string): Promise<boolean>;
    getBalance(address: string): Promise<number>;
    waitForBalance(address: string, expectedAmount: number, timeoutSeconds?: number, threshold?: number, anybalance?: boolean, noBalance?: boolean): Promise<number>;
    waitForMinBalance(address: string, minAmount: number, timeoutSeconds?: number): Promise<number>;
    waitForBalanceChange(address: string, startingAmount: number, timeoutSeconds?: number): Promise<number>;
    getTokenBalance(address: string, symbol: string): Promise<number>;
    waitForTokenBalance(address: string, symbol: string, expectedAmount: number, timeoutSeconds?: number, threshold?: number, anybalance?: boolean, noBalance?: boolean): Promise<number>;
    waitForMinTokenBalance(address: string, symbol: string, minAmount: number, timeoutSeconds?: number): Promise<number>;
    waitForTokenBalanceChange(address: string, symbol: string, startingAmount: number, timeoutSeconds?: number): Promise<number>;
}
export declare const GetAlgodIndexer: (url: string, port: string | number, token?: string) => algosdk.Indexer;
export declare const GetAlgodClient: (url: string, port: string | number, token: string) => algosdk.Algodv2;
