"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgorandBridgeTxnsV1 = exports.AlgorandBridgeTxnType = void 0;
const algosdk_1 = __importDefault(require("algosdk"));
const util = __importStar(require("util"));
const common_1 = require("../../../common");
var AlgorandBridgeTxnType;
(function (AlgorandBridgeTxnType) {
    AlgorandBridgeTxnType[AlgorandBridgeTxnType["none"] = 0] = "none";
    AlgorandBridgeTxnType["token_vault_setup"] = "token_vault_setup";
    AlgorandBridgeTxnType["token_vault_update_fee"] = "token_vault_update_fee";
    AlgorandBridgeTxnType["token_vault_update_limits"] = "token_vault_update_limits";
    AlgorandBridgeTxnType["token_vault_deposit"] = "token_vault_deposit";
    AlgorandBridgeTxnType["token_vault_release"] = "token_vault_release";
    AlgorandBridgeTxnType["token_vault_refund"] = "token_vault_refund";
    AlgorandBridgeTxnType["token_vault_optin"] = "token_vault_optin";
    AlgorandBridgeTxnType["xsol_release"] = "xSOL-release";
    AlgorandBridgeTxnType["algo_release"] = "algo-release";
    AlgorandBridgeTxnType["xsol_deposit"] = "xSOL-deposit";
    AlgorandBridgeTxnType["algo_deposit"] = "algo-deposit";
    AlgorandBridgeTxnType["xsol_refund"] = "xSOL-refund";
    AlgorandBridgeTxnType["algo_refund"] = "algo-refund";
    AlgorandBridgeTxnType["usdc_deposit"] = "usdc-deposit";
})(AlgorandBridgeTxnType = exports.AlgorandBridgeTxnType || (exports.AlgorandBridgeTxnType = {}));
class AlgorandBridgeTxnsV1 {
    //constructor
    constructor(algoClient, appId, transactions, accounts) {
        this._bridgeApprovalAppId = 0;
        this._client = undefined;
        this._transactions = undefined;
        this._accounts = undefined;
        this._client = algoClient;
        this._bridgeApprovalAppId = appId;
        this._transactions = transactions;
        this._accounts = accounts;
    }
    appArgs(functionName, routing, token) {
        const appArgs = [];
        let solana_asset = "";
        let app_asset_type = "";
        switch (functionName) {
            case AlgorandBridgeTxnType.token_vault_setup:
            case AlgorandBridgeTxnType.token_vault_update_fee:
            case AlgorandBridgeTxnType.token_vault_update_limits:
            case AlgorandBridgeTxnType.token_vault_optin:
                //Fail Safe
                if (!token)
                    throw new Error("Token Config is required");
                {
                    appArgs.push(new Uint8Array(Buffer.from(AlgorandBridgeTxnType[functionName]))); //0
                    appArgs.push(algosdk_1.default.encodeUint64(Number(token.address))); //1
                    appArgs.push(new Uint8Array(Buffer.from(token.symbol))); //2
                    appArgs.push(algosdk_1.default.encodeUint64(Number(token.decimals))); //3
                    appArgs.push(algosdk_1.default.encodeUint64(Number(token.fee_divisor))); //4
                    const min_transfer = token.min_transfer ? token.min_transfer : 0;
                    appArgs.push(algosdk_1.default.encodeUint64(Number(min_transfer * Math.pow(10, token.decimals)))); //5
                    const max_transfer = token.max_transfer ? token.max_transfer : 0;
                    appArgs.push(algosdk_1.default.encodeUint64(Number(max_transfer * Math.pow(10, token.decimals)))); //6
                }
                break;
            case AlgorandBridgeTxnType.xsol_deposit:
            case AlgorandBridgeTxnType.algo_deposit:
                //Fail Safe
                if (!routing)
                    throw new Error("Bridge Transaction is required");
                if (routing.to.network.toLowerCase() != "solana")
                    throw new Error("to network is not solana");
                if (routing.from.network.toLowerCase() != "algorand")
                    throw new Error("from network is not algorand");
                //Get Integer Amount
                {
                    if (!token)
                        throw new Error("Token Config is required");
                    if (!routing.units)
                        (0, common_1.SetRoutingUnits)(routing, token);
                    //Set Solana Asset
                    if (functionName == AlgorandBridgeTxnType.xsol_deposit) {
                        solana_asset = "sol";
                        app_asset_type = "xSOL";
                    }
                    else if (functionName == AlgorandBridgeTxnType.algo_deposit) {
                        solana_asset = "xALGoH1zUfRmpCriy94qbfoMXHtK6NDnMKzT4Xdvgms";
                        app_asset_type = "algo";
                    }
                    //Set routing units
                    if (routing.units) {
                        let token = common_1.BridgeTokens.get("algorand", app_asset_type);
                        (0, common_1.SetRoutingUnits)(routing, token);
                    }
                    appArgs.push(new Uint8Array(Buffer.from(routing.to.address))); //0 (Solana Address)
                    appArgs.push(new Uint8Array(Buffer.from(routing.from.address))); //1 (Algorand Address)
                    appArgs.push(new Uint8Array(Buffer.from(solana_asset))); //2 (Solana Asset)
                    appArgs.push(new Uint8Array(Buffer.from(app_asset_type))); //3 (Algorand Asset)
                    appArgs.push(new Uint8Array(Buffer.from(functionName.toString()))); //4 (App Call)
                    appArgs.push(new Uint8Array(Buffer.from(routing.to.txn_signature))); //5 (Solana Signature)
                    appArgs.push(algosdk_1.default.encodeUint64(Number(routing.units))); //6 (Amount)
                }
                break;
            case AlgorandBridgeTxnType.xsol_release:
            case AlgorandBridgeTxnType.algo_release:
            case AlgorandBridgeTxnType.xsol_refund:
            case AlgorandBridgeTxnType.algo_refund:
                //Fail Safe
                if (!routing)
                    throw new Error("Bridge Transaction is required");
                if (routing.from.network.toLowerCase() != "solana")
                    throw new Error("from network is not solana");
                if (routing.to.network.toLowerCase() != "algorand")
                    throw new Error("to network is not algorand");
                //Get Integer Amount
                if (!token)
                    throw new Error("Token Config is required");
                {
                    if (!routing.units)
                        (0, common_1.SetRoutingUnits)(routing, token);
                    //Set Solana Asset
                    if (functionName == AlgorandBridgeTxnType.xsol_release ||
                        functionName == AlgorandBridgeTxnType.xsol_refund) {
                        solana_asset = "sol";
                        app_asset_type = "xSOL";
                    }
                    else if (functionName == AlgorandBridgeTxnType.algo_release ||
                        functionName == AlgorandBridgeTxnType.algo_refund) {
                        solana_asset = "xALGoH1zUfRmpCriy94qbfoMXHtK6NDnMKzT4Xdvgms";
                        app_asset_type = "algo";
                    }
                    //Set routing units
                    if (routing.units) {
                        let token = common_1.BridgeTokens.get("algorand", app_asset_type);
                        (0, common_1.SetRoutingUnits)(routing, token);
                    }
                    appArgs.push(new Uint8Array(Buffer.from(routing.from.address))); //0 (Solana Address)
                    appArgs.push(new Uint8Array(Buffer.from(routing.to.address))); //1 (Algorand Address)
                    appArgs.push(new Uint8Array(Buffer.from(solana_asset))); //2 (Solana Asset)
                    appArgs.push(new Uint8Array(Buffer.from(app_asset_type))); //3 (Algorand Asset)
                    appArgs.push(new Uint8Array(Buffer.from(functionName.toString()))); //4 (App Call)
                    appArgs.push(new Uint8Array(Buffer.from(routing.to.txn_signature))); //5 (Solana Signature)
                    appArgs.push(algosdk_1.default.encodeUint64(Number(routing.units))); //6 (Amount)
                }
                break;
            case AlgorandBridgeTxnType.token_vault_deposit:
            case AlgorandBridgeTxnType.token_vault_release:
            case AlgorandBridgeTxnType.token_vault_refund:
                //Fail Safe
                if (!routing)
                    throw new Error("Bridge Transaction is required");
                if (!token)
                    throw new Error("Token Config is required");
                {
                    let from_signature = "null";
                    if (routing.from.txn_signature)
                        from_signature = routing.from.txn_signature;
                    //console.log(JSON.stringify(routing));
                    let from_pk = new Uint8Array();
                    if (routing.from.address && routing.from.network.toLocaleLowerCase() === "algorand")
                        from_pk = algosdk_1.default.decodeAddress(routing.from.address).publicKey;
                    let to_pk = new Uint8Array();
                    if (routing.to.address && routing.to.network.toLocaleLowerCase() === "algorand")
                        to_pk = algosdk_1.default.decodeAddress(routing.to.address).publicKey;
                    //Set routing units
                    if (routing.units) {
                        (0, common_1.SetRoutingUnits)(routing, token);
                    }
                    appArgs.push(new Uint8Array(Buffer.from(AlgorandBridgeTxnType[functionName]))); //0
                    appArgs.push(new Uint8Array(Buffer.from(routing.from.network))); //1
                    appArgs.push(new Uint8Array(Buffer.from(routing.from.address))); //2
                    appArgs.push(from_pk); //3
                    appArgs.push(new Uint8Array(Buffer.from(from_signature))); //4
                    appArgs.push(new Uint8Array(Buffer.from(routing.to.network))); //5
                    appArgs.push(new Uint8Array(Buffer.from(routing.to.address))); //6
                    appArgs.push(to_pk); //7
                    appArgs.push(algosdk_1.default.encodeUint64(Number(routing.units))); //8
                }
                break;
            default:
                return undefined;
        }
        return appArgs;
    }
    HandleUsdcSwap(routing) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (!routing)
                        throw new Error("Bridge Transaction is required");
                    if (!routing.from.address)
                        throw new Error("source is not defined");
                    if (!routing.to.address)
                        throw new Error("destination is not defined");
                    if (!routing.amount) {
                        throw new Error("amount can not be null");
                    }
                    //Fail Safe
                    if (!this._client)
                        throw new Error("Algorand Client is required");
                    if (!routing)
                        throw new Error("Bridge Transaction is required");
                    //Get Token
                    const token = yield common_1.BridgeTokens.get("algorand", routing.from.token);
                    if (!token)
                        throw new Error("Token Config is required"); // USDC bridge token is not added in SDK 
                    if (!routing.amount)
                        throw new Error("Routing Amount is required");
                    if (!this._transactions)
                        throw new Error("Algorand Transactions is required");
                    const amount_nanoUsdc = Math.round(routing.amount * 10 ** 6);
                    const routingData = {
                        from: {
                            token: "USDC",
                            network: "algorand",
                            address: routing.from.address,
                            txn_signature: "",
                        },
                        to: {
                            token: "USDC",
                            network: "solana",
                            address: routing.to.address,
                            txn_signature: "",
                        },
                        amount: routing.amount,
                        units: BigInt(amount_nanoUsdc),
                    };
                    let txn = this._transactions.initAlgorandUSDCTokenBridge(routingData, token);
                    resolve(txn);
                }
                catch (err) {
                    reject(err);
                }
            }));
        });
    }
    bridgeTransactions(routing, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    //Fail Safe
                    if (!routing)
                        throw new Error("Bridge Transaction is required");
                    if (!token)
                        throw new Error("Token Config is required");
                    if (!this.ValidateSendRouting(routing))
                        throw new Error("Invalid Routing");
                    //Set up Transactions
                    // algorand wallet algo|xsol|usdc 
                    let fn = AlgorandBridgeTxnType.none;
                    if (token.symbol.toLowerCase() === "algo") {
                        fn = AlgorandBridgeTxnType.algo_deposit;
                    }
                    else if (token.symbol.toLowerCase() === "xsol") {
                        fn = AlgorandBridgeTxnType.xsol_deposit;
                    }
                    let appTxn = yield this.BridgeApprovalTransaction(fn, routing, token); // switch for usdc 
                    let feeTxn = yield this.BridgeFeeTransaction(routing); // 
                    let depositTxn = yield this.BridgeDepositTransaction(routing);
                    let transactions = [appTxn, feeTxn, depositTxn];
                    resolve(transactions);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    ValidateSendRouting(routing) {
        let fNetwork = routing.from.network.toLowerCase();
        let fToken = routing.from.token.toLowerCase();
        let tNetwork = routing.to.network.toLowerCase();
        let tToken = routing.to.token.toLowerCase();
        if (fNetwork == "algorand" && fToken == "algo" && tNetwork == "solana" && tToken == "xalgo")
            return true;
        if (fNetwork == "algorand" && fToken == "xsol" && tNetwork == "solana" && tToken == "sol")
            return true;
        return false;
    }
    BridgeApprovalTransaction(functionName, routing, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f;
                try {
                    //Fail Safe
                    if (!this._client)
                        throw new Error("Algorand Client is required");
                    if (!routing)
                        throw new Error("Bridge Transaction is required");
                    //Get Default Parameters
                    const params = yield this._client.getTransactionParams().do();
                    params.fee = 1000;
                    params.flatFee = true;
                    //Encode Note
                    const record = {
                        routing: (0, common_1.RoutingString)(routing),
                        date: `${new Date()}`,
                    };
                    const note = algosdk_1.default.encodeObj(record);
                    //Get app args 
                    const appArgs = this.appArgs(functionName, routing, token);
                    //get accounts
                    const accounts = [];
                    switch (functionName) {
                        case AlgorandBridgeTxnType.xsol_deposit:
                            accounts.push(routing.from.address);
                            if (!((_a = this._accounts) === null || _a === void 0 ? void 0 : _a.asaVault))
                                throw new Error("ASA Vault is required");
                            accounts.push((_b = this._accounts) === null || _b === void 0 ? void 0 : _b.asaVault);
                            break;
                        case AlgorandBridgeTxnType.algo_deposit:
                            accounts.push(routing.from.address);
                            if (!((_c = this._accounts) === null || _c === void 0 ? void 0 : _c.algoVault))
                                throw new Error("Algo vault is required");
                            accounts.push((_d = this._accounts) === null || _d === void 0 ? void 0 : _d.algoVault);
                            break;
                        default:
                            accounts.push(routing.from.address);
                            if (!((_e = this._accounts) === null || _e === void 0 ? void 0 : _e.algoVault))
                                throw new Error("Algo vault is required");
                            accounts.push((_f = this._accounts) === null || _f === void 0 ? void 0 : _f.algoVault);
                            break;
                    }
                    //Get Bridge 
                    const txn = algosdk_1.default.makeApplicationNoOpTxnFromObject({
                        note: note,
                        suggestedParams: params,
                        from: routing.from.address,
                        accounts: accounts,
                        appIndex: Number(this._bridgeApprovalAppId),
                        appArgs: appArgs,
                        rekeyTo: undefined,
                    });
                    resolve(txn);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    BridgeFeeTransaction(routing) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                try {
                    //Fail Safe
                    if (!this._client)
                        throw new Error("Algorand Client is required");
                    if (!routing)
                        throw new Error("Bridge Transaction is required");
                    //Get Token
                    const token = yield common_1.BridgeTokens.get("algorand", routing.from.token);
                    if (!token)
                        throw new Error("Token Config is required");
                    if (!token.fee_divisor)
                        throw new Error("Token Fee Divisor is required");
                    if (!routing.amount)
                        throw new Error("Routing Amount is required");
                    if (!this._transactions)
                        throw new Error("Algorand Transactions is required");
                    if (!((_a = this._accounts) === null || _a === void 0 ? void 0 : _a.feeReceiver))
                        throw new Error("Fee Receiver is required");
                    //Get Fee Routing
                    const feeRouting = (0, common_1.RoutingDefault)(routing);
                    feeRouting.to.network = "algorand";
                    feeRouting.to.token = feeRouting.from.token;
                    feeRouting.to.address = (_b = this._accounts) === null || _b === void 0 ? void 0 : _b.feeReceiver;
                    feeRouting.units = undefined;
                    //Get Fee
                    feeRouting.amount = routing.amount / token.fee_divisor;
                    //Get Transaction
                    //  usdc 
                    let txn = undefined;
                    if (feeRouting.from.token.toLowerCase() === "algo") {
                        txn = yield this._transactions.sendAlgoTransaction(feeRouting);
                    }
                    else {
                        console.log(util.inspect(feeRouting, false, null, true /* enable colors */));
                        txn = yield this._transactions.sendTokensTransaction(feeRouting, token);
                    }
                    resolve(txn);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
    BridgeDepositTransaction(routing) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d;
                try {
                    //Fail Safe
                    if (!this._client)
                        throw new Error("Algorand Client is required");
                    if (!routing)
                        throw new Error("Bridge Transaction is required");
                    //Get Token
                    const token = yield common_1.BridgeTokens.get("algorand", routing.from.token);
                    if (!token)
                        throw new Error("Token Config is required");
                    if (!token.fee_divisor)
                        throw new Error("Token Fee Divisor is required");
                    if (!routing.amount)
                        throw new Error("Routing Amount is required");
                    if (!this._transactions)
                        throw new Error("Algorand Transactions is required");
                    //Get Fee Routing
                    const depositRouting = (0, common_1.RoutingDefault)(routing);
                    depositRouting.to.network = "algorand";
                    depositRouting.to.token = depositRouting.from.token;
                    depositRouting.units = undefined;
                    if (routing.from.token.toLowerCase() == "algo") {
                        if (!((_a = this._accounts) === null || _a === void 0 ? void 0 : _a.algoVault))
                            throw new Error("Algo Vault is required");
                        depositRouting.to.address = (_b = this._accounts) === null || _b === void 0 ? void 0 : _b.algoVault;
                    }
                    else {
                        if (!((_c = this._accounts) === null || _c === void 0 ? void 0 : _c.asaVault))
                            throw new Error("ASA Vault is required");
                        depositRouting.to.address = (_d = this._accounts) === null || _d === void 0 ? void 0 : _d.asaVault;
                    }
                    //Get Transaction
                    let txn = undefined;
                    if (depositRouting.from.token.toLowerCase() === "algo") {
                        txn = yield this._transactions.sendAlgoTransaction(depositRouting);
                    }
                    else {
                        console.log(util.inspect(depositRouting, false, null, true /* enable colors */));
                        txn = yield this._transactions.sendTokensTransaction(depositRouting, token);
                    }
                    resolve(txn);
                }
                catch (error) {
                    reject(error);
                }
            }));
        });
    }
}
exports.AlgorandBridgeTxnsV1 = AlgorandBridgeTxnsV1;
