"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlitterBridgeSDK = void 0;
const algorand_1 = require("./lib/chains/algorand");
const evm_1 = require("./lib/chains/evm");
const solana_1 = require("./lib/chains/solana");
const common_1 = require("./lib/common");
const networks_1 = require("./lib/common/networks/networks");
const config_1 = require("./lib/configs/config");
const mainnet_1 = require("./lib/configs/networks/mainnet");
const testnet_1 = require("./lib/configs/networks/testnet");
class GlitterBridgeSDK {
    constructor() {
        //RPC overrides
        this._rpcOverrides = {};
        this._evm = {
            ethereum: undefined,
            polygon: undefined,
            avalanche: undefined,
        };
    }
    //Setters
    setEnvironment(environment) {
        switch (environment) {
            case config_1.GlitterEnvironment.mainnet:
                this._bridgeConfig = mainnet_1.BridgeMainnet;
                break;
            case config_1.GlitterEnvironment.testnet:
                this._bridgeConfig = testnet_1.BridgeTestnet;
                break;
            default:
                throw new Error("Environment not found");
        }
        //Get Tokens
        let tokens = [];
        this._bridgeConfig.algorand.tokens.forEach((token) => {
            tokens.push(token);
        });
        this._bridgeConfig.solana.tokens.forEach((token) => {
            tokens.push(token);
        });
        common_1.BridgeTokens.loadConfig(tokens);
        return this;
    }
    setRPC(network, rpc) {
        this._rpcOverrides[network] = rpc;
        return this;
    }
    //Connectors
    connect(networks) {
        //Connect to the networks
        networks.forEach((network) => {
            switch (network) {
                case networks_1.BridgeNetworks.algorand:
                    this.connectToAlgorand();
                    break;
                case networks_1.BridgeNetworks.solana:
                    this.connectToSolana();
                    break;
                case networks_1.BridgeNetworks.Ethereum:
                    this.connectToEvmNetwork(networks_1.BridgeNetworks.Ethereum);
                    break;
                case networks_1.BridgeNetworks.Polygon:
                    this.connectToEvmNetwork(networks_1.BridgeNetworks.Polygon);
                    break;
                case networks_1.BridgeNetworks.Avalanche:
                    this.connectToEvmNetwork(networks_1.BridgeNetworks.Avalanche);
                    break;
            }
        });
        return this;
    }
    connectToAlgorand() {
        //Failsafe
        if (!this._bridgeConfig)
            throw new Error("Glitter environment not set");
        if (!this._bridgeConfig.algorand)
            throw new Error("Algorand environment not set");
        if (this._rpcOverrides[networks_1.BridgeNetworks.algorand]) {
            console.log("Algorand RPC override: " + this._rpcOverrides[networks_1.BridgeNetworks.algorand]);
            this._bridgeConfig.algorand.serverUrl =
                this._rpcOverrides[networks_1.BridgeNetworks.algorand];
        }
        //Get the connections
        this._algorand = new algorand_1.AlgorandConnect(this._bridgeConfig.algorand);
        if (!this._algorand.client)
            throw new Error("Algorand client not set");
        return this;
    }
    connectToSolana() {
        var _a;
        //Failsafe
        if (!this._bridgeConfig)
            throw new Error("Glitter environment not set");
        if (!this._bridgeConfig.solana)
            throw new Error("Solana environment not set");
        if (this._rpcOverrides[networks_1.BridgeNetworks.solana]) {
            console.log("Solana RPC override: " + this._rpcOverrides[networks_1.BridgeNetworks.solana]);
            this._bridgeConfig.solana.server =
                this._rpcOverrides[networks_1.BridgeNetworks.solana];
        }
        this._solana = new solana_1.SolanaConnect((_a = this._bridgeConfig) === null || _a === void 0 ? void 0 : _a.solana);
        //(this._glitterNetwork.algorand.appProgramId);
        if (!this._solana.client)
            throw new Error("Solana client not set");
        return this;
    }
    connectToEvmNetwork(network) {
        //Failsafe
        if (!this._bridgeConfig)
            throw new Error("Glitter environment not set");
        if (!this._bridgeConfig.evm[network])
            throw new Error("EVM environment not set");
        if (this._rpcOverrides[network]) {
            this._bridgeConfig.evm[network].rpcUrl = this._rpcOverrides[network];
        }
        this._evm[network] = new evm_1.EvmConnect(network, this._bridgeConfig.evm[network]);
        return this;
    }
    /**
     * Returns EVMConnect for
     * a specific evm network
     * @param {BridgeEvmNetworks} network
     * @returns {EvmConnect | undefined}
     */
    getEvmNetwork(network) {
        return this._evm[network];
    }
    //Getters
    get algorand() {
        return this._algorand;
    }
    get solana() {
        return this._solana;
    }
}
exports.GlitterBridgeSDK = GlitterBridgeSDK;
